#!/bin/bash
#
# Usage: data-viewer DATAFILE [COLUMNS]
#
#  Create an executable from DATAFILE which may be run to provide
#  different views of the data.
#
#  All remaining arguments (i.e., COLUMNS) should be the names of the
#  columns of data in DATAFILE in order.  So for example, with data
#  like the following,
#
#     bubble cpp g++ O0 395
#     bubble cpp g++ O2 412
#     insertion c clang O0 393
#     insertion c clang O1 469
#     insertion c gcc O0 307
#     insertion c gcc O1 337
#     ...
#
#  Run the following to generate an executable data viewer named
#  neut-viewer.
#
#     data-viewer neut algorithm language compiler flag result
#
#
# NOTE: for now, all column names must have unique first letters
#
#
contains(){ echo "$1"|grep "$2" >/dev/null 2>/dev/null; }
HELP_TEXT=$(cat "$0" \
    |sed '/^[^#]/q' \
    |head -n -1 \
    |tail -n +3 \
    |sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' \
    |cut -c3-)
if $(contains "$1" "^\-\?\-h\(elp\|$\)");then echo "$HELP_TEXT"; exit 1;fi
SCRIPT="$(cat "$0"|sed -n '/^SCRIPT:/,$p'|tail --lines=+2)"
DATAFILE="$1"; shift;
SCRIPTFILE="$DATAFILE-viewer"
COUNTER=0
CASE=""
COL_TEXT=""
for col in $@;do
    COUNTER=$(expr $COUNTER + 1)
    PRE=""
    for i in $(seq 1 $(expr $(echo "$col"|wc -c) - 1));do
        PRE="$(echo "$col"|cut -c-$i)"
        if ! $(contains "$(echo "${COLUMNS[@]}"|tr ' ' '\n')" "^$PRE");then
            break;
        fi
    done
    COLUMNS[$COUNTER]=$col
    CASE+="${PRE}*) echo $COUNTER;; "
    COL_TEXT+="$col, "
    # default result column
    COL0=$col
done
COL1=$(echo ${COLUMNS[1]}|cut -c1-4)
COL2=$(echo ${COLUMNS[2]}|cut -c1-4)

SED="s/SCRIPT/$(basename $SCRIPTFILE)/g;"
SED+="s/COLUMNS/${COL_TEXT%??}/g;"
SED+="s/COL0/$COL0/g;"
SED+="s/COL1/$COL1/g;"
SED+="s/COL2/$COL2/g;"
SED+="s/CASE/$CASE/g;"

# echo "$SED"
# exit 0

echo "$SCRIPT"|sed "$SED" > $SCRIPTFILE
cat "$DATAFILE" >> $SCRIPTFILE
chmod +x $SCRIPTFILE
echo "Wrote script to $SCRIPTFILE."
exit 0;


SCRIPT:
#!/bin/bash
#
# Usage: SCRIPT [options...] [action]
#
# Options:
#  -h --help ------------- print this help message
#  -i --include COL=STR -- only include items with COL=STR in results
#  -e --exclude COL=STR -- exclude items with COL=STR from results
#  -b --by [COL,...] ----- group results by COLs (comma separated)
#  -r --res [COL,...] ---- print results for COLs
#                          (comma separated, defaults to COL0)
#  -g --graph ------------ graph mean of results (requires gnuplot)
#  -o --output FILE ------ save output to FILE
#
# Actions (specify at most one to reduce results):
#  -m --mean ------------- mean of all matching results
#  -s --sum -------------- mean of all matching results
#  -c --cor -------------- Pearson correlation between two categories
#  -t --t-test ----------- t test between all groups of results
#                          (use at most one category, requires Rscript)
#  -k --ks-test ---------- Kolomogorov-Smirnov between all groups of
#                          results (at most one category, Rscript)
#  -n --normal-test ------ Shapiro-Wilk test for normality (Rscript)
#
# Columns (COL):
#  One of COLUMNS.  Substrings may be
#  used, e.g., "a" for "algorithm".
#
# Examples:
#
#   to print a table of the mean value by COL1 and COL2, use:
#
#     SCRIPT -b COL1,COL2 -m
#
#   to calculate the total value by COL1, and graph the results to an
#   svg file, use:
#
#     SCRIPT -b COL1 -m -g -o /tmp/by-lang.svg
#
#
contains(){ echo "$1"|grep "$2" >/dev/null 2>/dev/null; }
has(){ which "$1" >/dev/null 2>/dev/null; }
error(){ echo "$0: $@" >&2; exit 1; }
TITLE="$0 $@"
NUM_ARGS="$#"
ACT="all"
OUT=""
GRAPH=""
declare -a INC
declare -a EXC
declare -a CAT
declare -a RES
declare -a RES_NAMES
row(){ # match categories to rows in the data
    case $1 in
        CASE
        *) error "Category '$i' does not match any category.";;
    esac; }
add_cat(){
    local cat="$1";
    local length=${#CAT[@]};
    if [ $length -gt 1 ];then error "Can specify at most two categories.";
                         else CAT[$length]=$cat; fi; }
add_act(){
    local act="$1";
    if [ ! "$ACT" == "all" ];then error "Can specify at most one action.";
                             else ACT=$act; fi; }
add_inc_exp(){
    local type=$1;
    local pair="$2";
    local cat="$(row $(echo "$pair"|sed 's/=.*$//'))"
    local it="$(echo "$pair"|sed 's/^.*=//')"
    case $type in
        "INC") INC+=($cat); INC+=($it);;
        "EXC") EXC+=($cat); EXC+=($it);;
        *) error "Impossible type $type.";;
    esac; }

DATA="$(cat "$0"|sed -n '/^DATA:/,$p'|tail --lines=+2)"

HELP_TEXT=$(cat "$0" \
        |sed '/^[^#]/q' \
        |head -n -1 \
        |tail -n +3 \
        |sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' \
        |cut -c3-)

eval set -- $(getopt \
    -o hi:e:b:r:msctkngo: \
    -l help,include:,exclude:,by:,res:,mean,sum,cor,t-test,ks-test,normal-test,graph,output: \
    -- $@ || echo "$HELP_TEXT" && exit 1;)

while [ $# -gt 0 ];do
    case $1 in
        -h|--help)      echo "$HELP_TEXT" && exit 1;;
        -i|--include)   add_inc_exp "INC" "$2"; shift;;
        -e|--exclude)   add_inc_exp "EXC" "$2"; shift;;
        -b|--by)
            SAVE="$IFS"; IFS=","
            for i in $2;do
                row $i >/dev/null || exit 1
                add_cat $(row $i)
            done
            shift; IFS="$SAVE";;
        -r|--res)
            SAVE="$IFS"; IFS=","
            for i in $2;do
                row $i >/dev/null || exit 1
                RES+=($(row $i))
                RES_NAMES+=($i)
            done
            shift; IFS="$SAVE";;
        -m|--mean)      add_act "mean";;
        -s|--sum)       add_act "sum";;
        -c|--cor)       add_act "cor";;
        -n|--normal-test) add_act "normal";;
        -t|--t-test)    add_act "t_test";;
        -k|--ks-test)   add_act "ks_test";;
        -g|--graph)     GRAPH="yes";;
        -o|--output)    OUT="$2"; shift;;
        (--) shift; break;;
        (-*) error "unrecognized option $1";;
        (*)  break;;
    esac
    shift
done
if [ ${#RES[@]} -eq 0 ];then
    RES[0]=$(row "COL0");
    RES_NAMES[0]="COL0";
fi

# Functions
inc(){
    local cat=$1; local match=$2;
    awk "{ if (\$$cat == \"$match\") print \$0; }"; }

exc(){
    local cat=$1; local match=$2;
    awk "{ if (\$$cat != \"$match\") print \$0; }"; }

res_awk(){
    echo -n "{ print "
    for col in ${RES[@]};do
        echo -n "\$$col";
        if [ ! "$col" == "${RES[${#RES[@]}-1]}" ];then echo -n ", "; fi
    done
    echo "; }";}
res(){ awk "$(res_awk)"; }
transpose(){
    awk '{ for (f=1; f<=NF; f++) a[NR, f] = $f }
         NF > nf { nf = NF }
         END { for (f=1; f<= nf; f++)
                 for (r=1; r<=NR; r++)
                     printf a[r,f] (r==NR ? RS : FS); }'; }

# Complex stats with R
r_prefix='d <- read.table("stdin", header=FALSE, fill=TRUE);'
r_prefix+='x <- as.vector(d[,1]); col1 <- x[!is.na(x)]; '
r_prefix+='if(length(d) > 1){ y <- as.vector(d[,2]); col2 <- y[!is.na(y)]; }; '
t_test(){
    Rscript -e "$r_prefix t.test(col1,col2)" 2>/dev/null \
        |sed 's/,//g;s/=//g' \
        |grep p-value \
        |awk '{printf "%s(%s)", $2, $6}'; }
ks_test(){
    Rscript -e "$r_prefix ks.test(col1,col2)" 2>/dev/null \
        |sed 's/,//g;s/=//g' \
        |grep p-value \
        |awk '{printf "%s(%s)", $2, $4}'; }
cor_test(){
    Rscript -e "$r_prefix cor.test(col1,col2)" 2>/dev/null \
        |tr '\n' ' ' \
        |sed 's/^.*p-value = //;s/ alternative.* cor / /;s/ *$//' \
        |awk '{printf "%s(%s)", $2, $1}'; }
norm_test(){
    Rscript -e "$r_prefix shapiro.test(col1)" \
        |sed 's/,//g;s/=//g' \
        |grep p-value \
        |awk '{printf "%s(%s)", $2, $4}'; }

# Run all actions using awk or R
act(){
    case $ACT in
        all)  awk '{ for (i=1; i<=NF; i++){ sum[i][NR] = $i; } }
                   END { if(NR == 0) print "NA"; else
                     for (i=1; i<=NF; i++){
                       for (j=1; j<=NR; j++){
                         printf "%s", sum[i][j]; if(j<NR) printf ",";}
                       if(i<NF) printf " ";}}';;
        sum)  awk '{ for (i=1; i<=NF; i++){ sum[i] += $i; } }
                   END { if(NR == 0) print "NA"; else
                     for (i=1; i<=NF; i++){
                       printf "%s", sum[i];
                       if(i<NF) printf " "; }}';;
        mean) awk '{ for (i=1; i<=NF; i++){ sum[i] += $i; } }
                   END { if(NR == 0) print "NA"; else
                     for (i=1; i<=NF; i++){
                       printf "%s", sum[i]/NR;
                       if(i<NF) printf " ";}}';;
        t_test)  t_test;;
        ks_test) ks_test;;
        cor)     cor_test;;
        normal)  norm_test;;
    esac|sed 's/ /\//g'; }

# Tabled data or graphs with gnuplot
post_process(){
    if [ ! -z "$GRAPH" ];then
        if [ ! -z "$OUT" ];then OUT="set term $OUT;"; fi
        TMPFILE="/tmp/$(basename $0).temp-data"
        if [ $(has gnuplot) ];then
            error "Graphing requires the gnuplot executable."
        elif ([ "$ACT" == "all" ] || $(contains "$ACT" "test"));then
            # graph a line for each line of output (needs labels)
            MYDATA=$(sed 's/,/ /g'|transpose)
            echo "$MYDATA" > "$TMPFILE"
            NUMCOLS=$(echo "$MYDATA"|head -1|awk '{ print NF }')
            OUT+="set key autotitle columnhead;"
            OUT+="set title '$TITLE';"
            OUT+="set yrange [0:];"
            OUT+="plot for [i=1:$NUMCOLS] '$TMPFILE' u i w l,"
            gnuplot -persist -e "$OUT"
        elif [ ${#CAT[@]} -ne 1 ];then
            error "TODO: 3D graphs for multiple categories."
        else
            # graph a histogram for each line of output
            if [ ${#RES[@]} -gt 1 ];then
                MYDATA=$(sed 's/\// /g')
                echo "$MYDATA" > "$TMPFILE"
                OUT+="set title '$TITLE';"
                OUT+="set style histogram clustered gap 5;"
                OUT+="set style fill solid border -1;"
                OUT+="set style data histograms;"
                OUT+="set yrange [0:];"
                OUT+="set y2range [0:];"
                OUT+="set y2tics;"
                OUT+="set ytics nomirror;"
                OUT+="set ylabel '${RES_NAMES[0]}';"
                OUT+="set y2label '${RES_NAMES[1]}';"
                OUT+="set key out above;"
                OUT+="plot '$TMPFILE' u 2:xtic(1) axes x1y1 ti '${RES_NAMES[0]}', "
                OUT+="'$TMPFILE' u 3 axes x1y2 ti '${RES_NAMES[1]}'"
                gnuplot -persist -e "$OUT"
            else
                MYDATA=$(sed 's/,/ /g')
                echo "$MYDATA" > "$TMPFILE"
                OUT+="set title '$TITLE';"
                OUT+="set style fill solid border -1;"
                OUT+="set yrange [0:];"
                OUT+="plot '$TMPFILE' using 2:xtic(1) w boxes notitle;"
                gnuplot -persist -e "$OUT"
            fi
        fi
        # rm "$TMPFILE"        
    else
        if [ ! -z "$OUT" ];then
            echo "# $TITLE">$OUT
            cat >>$OUT
            echo "Wrote output to $OUT"
        else
            column -t
        fi
    fi; }

# Main
for ((i=0; i<${#INC[@]}; i+=2));do
    DATA="$(echo "$DATA"|inc ${INC[i]} ${INC[i+1]})"
done
for ((i=0; i<${#EXC[@]}; i+=2));do
    DATA="$(echo "$DATA"|exc ${EXC[i]} ${EXC[i+1]})"
done

case ${#CAT[@]} in
    0)
        if [ $NUM_ARGS -eq 0 ];then
            echo "$DATA"
        else
            echo "$DATA"|res|act
        fi;;
    1)
        CATS="$(echo "$DATA"|awk "{print \$${CAT[0]}}"|sort -u)"
        if $(contains "$ACT" "test");then
            if [ ${#RES[@]} -gt 1 ];then
                error "Only one result column at a time for statistical tests.";
            fi
            echo "[$(echo "$CATS"|wc -l)x$(echo "$CATS"|wc -l)] $(echo $CATS)"
            for x in $CATS;do
                XS="$(echo "$DATA"|inc ${CAT[0]} $x|res)"
                echo -n "$x"
                for y in $CATS;do
                    YS="$(echo "$DATA"|inc ${CAT[0]} $y|res)"
                    sets="$(echo "$(echo "$XS"|tr '\n' ' ')";
                            echo "$(echo "$YS"|tr '\n' ' ')")"
                    echo -n " $(echo "$sets"|transpose|act)"
                done
                echo ""
            done
        else
            for i in $CATS;do
                echo "$i $(echo "$DATA"|inc ${CAT[0]} $i|res|act)"
            done
        fi;;
    2)
        if $(contains "$ACT" "test");then
            error "Can group by at most one column when running a T test."
        fi
        XS="$(echo "$DATA"|awk "{print \$${CAT[0]}}"|sort -u)"
        YS="$(echo "$DATA"|awk "{print \$${CAT[1]}}"|sort -u)"
        echo "[$(echo "$XS"|wc -l)x$(echo "$YS"|wc -l)] $(echo $YS)"
        for x in $XS;do
            echo -n "$x"
            for y in $YS;do
                echo -n " $(echo "$DATA"|inc ${CAT[0]} $x|inc ${CAT[1]} $y|res|act)"
            done
            echo ""
        done;;
esac|post_process
exit 0;


# The rest of the file should be raw data.
DATA:
